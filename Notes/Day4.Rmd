---
title: "R4BD - Day 4"
author: "Pr. Charles BOUVEYRON"
date: "5/7/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Handling massive data with the `dplyr` package

The `dplyr` package offers an ensemble of functions and formats that allow to manage and manipulate very large data sets and to explore them in an intuitive way.The idea is to manipulate the data in a way which is closer to the way people think.

We first need to install the library:

```{r}
# install.packages("dplyr")
library(dplyr)
```

The above messsages warn you that `dplyr` loaded some functions that overwrite existing functions in the R environnemnt. For instance, unitil you restart R, the `filter` function will refer to the function within the `dplyr` package and not anymore to the one in the `stats` package.

The `dplyr` package is organised around 5 main functions:

- the `filter` function which allows to select a part of the data and to work with,
- the `arrange` function which aims to sort the data,
- the `select` function that operates on variables to make a selection,
- the `mutate` function which allows to create new variables,
- the `summarise` function which produces summaries about the data at hand.

In order to illustrate the use of the `dplyr` package, we will use the `flights` data set that is provided in the `nycflights13` package.

```{r}
#install.packages('nycflights13')
library(nycflights13)
data(flights)
```

We can of course consult the documentation of the data: `?flights`. We can see that the data set gathers information about all flights that departed NYC in 2013. As we can check, it is a quite massive data set:

```{r}
dim(flights)
```

The 19 variables describe the 336776 flights that departed NYX in 2013.

## The `filter` function

The `filter` function is proposed to manipulate the data, and in particular to extract a subset of the data according to some selection criteria.

A first example: select all flights that departed from 'JFK' airport during this year.

```{r}
JFK = filter(flights,origin == 'JFK')
dim(JFK)
```

> Remark: in `dplyr`, you do not have to put `flights$origin` or `"origin"` to access the target variable. The way we specify the condition is therefore closer to the way we think. 

Just for the record, this would be the same selection with the basic R:

```{r}
JFK2 = flights[flights$origin=='JFK', ]
dim(JFK2)
```

We can also compare the computing time to do this task:

```{r}
system.time(filter(flights,origin == 'JFK'))
system.time(flights[flights$origin=='JFK', ])
```

Event though both approaches are quite fast, the `filter` approach is clearly faster than the usual one. 

We can also make a selection according to several variables:

```{r}
X = filter(flights,origin == 'JFK', dest == 'LAX')
dim(X)
```

This command creates the subset of the flights that departed from JFK and that landed in LAX (Los Angeles).

If needed, it is of course possible to use the `&` and `|` operators.

> Exercise: create the subset of all flights that landed in 'LAX' in May or June 2013.

```{r}
X = filter(flights, dest=='LAX',(month==5 | month==6))
dim(X)
```

> Exercise: create the subset of all flights that flew from 'JFK' to Boston 'BOS' and arrived with a delay larger than 30 min, between May 1st and July 31th 2013.

```{r}
X = filter(flights,origin == 'JFK', dest == 'BOS', month %in% 5:7, arr_delay >= 30)
dim(X)
```

In order to look at which companies are frequently late on this destination, we can use the `table` function as usual:

```{r}
table(X$carrier)
airlines
```


> Warning: the `filter` and the basic R alternative are usually working in the same way, except regarding the treatment of missing values!

```{r}
X = filter(flights,origin == 'JFK', dest == 'BOS', month %in% 5:7, arr_delay >= 30)
dim(X)

Y = flights[flights$origin == 'JFK' &
            flights$dest == 'BOS' &
            flights$month %in% 5:7 &
            flights$arr_delay >= 30, ]
dim(Y)
```

This practical example shows that `filter` does not select the flights for which there is a missing value on one of the variables that are used to make the selection, whereas R selects those flights.

## The `arrange` function

After having made a selection of a subset of the original data, it may be interesting to look at the data, but they are usually ordered in a random manner.The `arrange` function aims at reordoring the data before to be displayed. It is usually very useful in combination to `filter`.

A typical example:

```{r}
X = filter(flights,origin == 'JFK', dest == 'BOS', month %in% 5:7, arr_delay >= 30)

#Y = arrange(Y,arr_delay) # increasing order

X = arrange(X,desc(arr_delay)) # decreasing order
X
```

It is also possible to specify an ordering according to several variables:

```{r}
X = arrange(X,month, day)
X
```

> Exercise: sort the flights by company and then by worst delay.

```{r}
Y = arrange(Y,carrier,desc(arr_delay))
Y
```

## The `select` function

The `select` function aims to make a selection of the original variables to extract a smaller table restricted to some selected variables.

```{r}
X = select(flights,flight,month,day,arr_delay)
dim(X)
X
```

Of course, the `select` function is very often used in combination to the `filter` and the `arrange` functions.

```{r}
X = filter(flights,origin == "JFK",dest == "BOS", arr_delay >= 30)
X = select(X,flight, carrier, month, day, arr_delay)
dim(X)
```

> Exercise: use the `filter` and `select` functions to create a smaller table focusing on the flights that flew from 'EWR' to 'LAX' in May to July 2013 and produce boxplots for each carrier to display the distribution of arrival delays per company.

```{r}
X = filter(flights,origin == "EWR",dest == "LAX", month %in% 5:7)
X = select(X,flight,carrier,arr_delay)
dim(X)

library(ggplot2)
ggplot(data = X) + 
  geom_boxplot(aes(x='',y=arr_delay)) +
  facet_wrap(~ carrier,ncol = 4)
```

It may be also possible to focus to only late flights (>=30 min):

```{r}
X = filter(flights,origin == "EWR",dest == "LAX", month %in% 5:7, arr_delay >= 60)
X = select(X,flight,carrier,arr_delay)
dim(X)

library(ggplot2)
ggplot(data = X) + 
  geom_boxplot(aes(x='',y=arr_delay)) +
  facet_wrap(~ carrier,ncol = 4)
```

## The `mutate` function

The `mutate` function simply aims at adding new variables to an exsiting table by computation from the original variables.

An example of this:

```{r}
flights = mutate(flights,dist_km = distance * 1.60934)
dim(flights)
ggplot(data = flights) + 
  geom_boxplot(aes(x='',y=dist_km)) +
  facet_wrap(~ carrier,ncol = 4)
```

> Exercise: do the same with the classical R command

```{r}
flights$dist_km = flights$distance * 1.60934
dim(flights)
```

> Exercise: add to the `flight` data set a new variable `delay_gain` which provides the gain in delay between the departure and the arrival. Then, visualize the distribution of this new variable, according to the company.

```{r}
flights = mutate(flights,delay_gain = dep_delay - arr_delay)
# A positive value corresponds to a gain regarind the delay
# and a negative value corresponds to an arrival delay worst than the departure delay
dim(flights)

ggplot(data = flights) + 
  geom_boxplot(aes(x='',y=delay_gain)) +
  facet_wrap(~ carrier,ncol = 8)
```

The above figure shows that almost all companies are able to reduce the delay during the flight.

## The `summarise` function

The `summarise` function simply aims to provide some nice summaries about the data, by asking precisely the statistics to compute.

```{r}
mySum = summarise(flights,
                  dep_delay_mean = mean(dep_delay,na.rm=TRUE),
                  dep_delay_sd = sd(dep_delay,na.rm=TRUE),
                  arr_delay_mean = mean(arr_delay,na.rm=TRUE),
                  arr_delay_sd = sd(arr_delay,na.rm=TRUE))
mySum
```

This function has an alternative in R, the `summary` fonction, but this function can not be parametrized (the computed statistics are fixed!).

```{r}
summary(flights)
```

The `summarise` function may be combined with the `group_by` function to produce meaninful summaries:

```{r}
flights_grp = group_by(flights,carrier)
mySum = summarise(flights_grp,
                  dep_delay_mean = mean(dep_delay,na.rm=TRUE),
                  dep_delay_sd = sd(dep_delay,na.rm=TRUE),
                  arr_delay_mean = mean(arr_delay,na.rm=TRUE),
                  arr_delay_sd = sd(arr_delay,na.rm=TRUE))
mySum
```

> Exercise: build a summary with some usefult statistics about the arrival delay depending on the month of the year. Then, plot some of those information.


```{r}
flights_grp = group_by(flights,month)
mySum = summarise(flights_grp,
                  arr_delay_mean = mean(arr_delay,na.rm=TRUE),
                  arr_delay_sd = sd(arr_delay,na.rm=TRUE))
mySum
```

```{r}
ggplot(data = mySum) +
  geom_line(aes(x=month,y=arr_delay_mean))
```

The `group_by` function may also be applied to several variables at the same time:

```{r}
flights_grp = group_by(flights,carrier,month)
mySum = summarise(flights_grp,
                  arr_delay_mean = mean(arr_delay,na.rm=TRUE),
                  arr_delay_sd = sd(arr_delay,na.rm=TRUE))
mySum
```

```{r}
ggplot(data = mySum) +
  geom_boxplot(aes(x=factor(month),y=arr_delay_mean))
```

## The pipe operator

The piper operator `%>%` allows to chain a sequence of `dyplyr` commands in order to ease again the interaction between the analyst and the software.

Let's first consider this example:

```{r}
flights %>% mutate(gain_delay = dep_delay - arr_delay) %>%
  group_by(month) %>%
  summarise(gain_delay_mean = mean(gain_delay,na.rm=TRUE),
            gain_delay_sd = sd(gain_delay,na.rm=TRUE),)
```

Remember that earlier wa had to save the result of both the `mutate` and the `group_by` functions, before to apply `summarise`.

The table which is produced can be of course saved as follows:

```{r}
mySum = flights %>% mutate(gain_delay = dep_delay - arr_delay) %>%
  group_by(month) %>%
  summarise(gain_delay_mean = mean(gain_delay,na.rm=TRUE),
            gain_delay_sd = sd(gain_delay,na.rm=TRUE))

mySum
```

The pipe operator is of course well appreciated when we have to chain a lot of commands.

> Exercise: Produce a table, *using the pipe operator*, that gathers the maximum and minimum values for the delay gain depending on the month of the year and the destination, for all flights operated by Delta Airlines and that departed 'JFK' before the end of March 2013.

```{r}
mySum = flights %>%
  filter(origin == 'JFK', carrier == 'DL', month %in% 1:3) %>%
  mutate(gain_delay = dep_delay - arr_delay) %>%
  group_by(month, dest)%>%
  summarise(gain_delay_min = min(gain_delay,na.rm=TRUE),
            gain_delay_max = max(gain_delay,na.rm=TRUE))
mySum

ggplot(data = mySum) +
  geom_boxplot(aes(x=factor(month),y=gain_delay_max))

ggplot(data = mySum) +
  geom_boxplot(aes(x=factor(dest),y=gain_delay_max))
```

# Relational data, dates and maps

The modern data that we can encounter when dealing with real-world applications are often more complex than just continous or categorical data. For instance, it is more and more frequent to have to deal with functional data, networks, texts, images, geographical data, ... and those data can also be stored in different files and even in different places.

## Relational data

A set of relational data is usually made of several data files, each focusing on a specific aspect of the data, and that are linked together thanks to some identification code. For instance, in the `nycflights13`, the `flights` data table is linked to two other tables, the `airports` and `airlines` tables, thanks to the ID of the airports and the companies, respectively.

Usually, it is at some point necessary to join the diffent tables in a unique table. In order to join two tables, the `dplyr` package provides some useful fonctions: `inner_join`, `left_join`, `right_join` and the `full_join` functions. We provide herafter a few practical examples of using these functions:

As an example, let's consider two data tables `A` and `B`:

```{r}
A = data.frame(id=c(1,2,4,6,7),x=rnorm(5),y=c(1,2,78,NA,-5))
B = data.frame(id=c(1,2,3,4,5),z=runif(5))
A
```


```{r}
B
```

> Remark: it is worth noticing that the two data tables have some different individuals inside.

Now, let's try to use the `inner_join` function on them:

```{r}
inner_join(A,B,by='id')
```

This function allows to join the two tables by restricting only on the individuals that are present in both tables.

The other functions work as follows:

```{r}
left_join(A,B,by='id')
```

Here, `left_join` complete the table `A` whith the variable `z` for the individuals that are also present in `B`.

```{r}
right_join(A,B,by='id')
```


```{r}
full_join(A,B,by='id')
```

> Exercise: add to the `flights` data table the name of the origin airports, using the `airports` data table.

```{r}
flights = flights %>% 
  mutate(faa = origin) %>%
  left_join(airports,by='faa')
flights
```


An alternative would be:

```{r}
left_join(flights, airports, by = c('origin' = 'faa'))
```


## Manipulating dates

It is now very frequent to have to manipulate dates and those data are versy specific because they live in a continous time. In R, it is possible to manipulate dates as ... `date`.

A basic input woul be:

```{r}
today = '2020-05-07'
another_date = '2017-09-25'
today
class(today)
```

If we enter dates without telling to R that are dates, they are just recognized as strings. The command to tell R they are dates is `as.Date`:

```{r}
today = as.Date('2020-05-07')
another_date = as.Date('2017-09-25')

today - another_date
today + 1
```

Thanks to this, it is very easy to manipulate those data. For instance, when considering the `flights` data set, it is possible to look at the temporal discrtibution of the flights as follows:

```{r}
dates = flights %>% select(year,month,day) %>%
  mutate(date=as.Date(paste(year,month,day,sep='-')))
hist(dates$date,breaks = 'months')
```

## The maps

When we are working with geographical data, it may be of course interesting to display the results as maps.  Several libraries are available for this, but we will just look at two: `maps` and `leaflet`.

```{r}
#install.packages('maps')
library(maps)
map()
```

After, it is possible to plot the position of some place thanks to the longitude and latitude coordinates:

```{r}
map("usa")
points(airports$lon,airports$lat,pch=19,col='lightblue')
```

With `leaflet`, a similar result can be obtained as follows:

```{r}
#install.packages('leaflet')
library(leaflet)

map <- leaflet() %>%
  addTiles() %>%
  addMarkers(lng=airports$lon,lat=airports$lat)

map
```














